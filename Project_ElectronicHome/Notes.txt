COn respecto a los productos
//cuando se estén ingresando
//media vez se haya ingresado el nombre Y la marca
//además de la "oficina/sucursal"
    //se procederá a buscar el stock, pues esos datos son los nec
    //para hallar el stock respectivo
    //puesto que la tabla "PRODUCTO" almacena el stock al que pertenece
    //y este tiene la "sucursal" en la que se encuentra.

    //o sea la búsqueda sería así
        //SEARCH en producto, aquel que tenga el name y brand ingresados
        //THEN, IF you have an office SO you are going to search the stock
        //THEN, ELSE you don't have stock, you are going to show nothing
        //on the stock area.
            //IF you have already a name, brand and office, and there is no
            //stock, SO you are going to "create" it
                //and I used quotations because it is going to be created 
                //without postgres, then if there is no changes SO, you are
                //going to create this stock.

        
    //en el caso de los stock de bodega, estos van a tener diferente inicial
    //en el code, como SBA y los de tienda SOA (store bodega/office available)

    //ya con ese código, no será necesario crear otra entidad, pues con ese distintivo
    //basta. Porque si creo bodega como entidad, solo tendría nombre y almacenaría
    //los stock con los distintivos
        //lo cual sería como si creara un stock solo para apartar esos stock
        //lo cual no está mal, para orden pero xD, si quieres no hacer no lo hagas
        //da tremendamente igual.


//Purchase
    //es la tabla que almacena una fila por cada conjunto de producto igual
//CUando se vaya a hacer insert, transfer o venta, el stock ser revisará
//después de tener la "sucursal" así como lo escribiste y rep en tu cuaderno

//CONTRACT
    //ese es para relacionar al employee with the office

//APPLIANCE
    //lo cree para que cuando se tenga un producto nunevo, sin precio, entonces
    //se coloque ahí

//PRODUCT
    //cuando un appliance ya tiene precio
    //a partir de este será con el que se harán los JOIN, puesto que tiene stock
    //y appliance

//Office
    //más que todo se usará par insertar y para consultar y add info

//OPERACIONES
    //Con respecto a los dctos, después de preguntar voy a app en la tabla, o
    //con el programa sin guardarlo, dep de la respuesta.

//SALE
    //se creará en un principio antes de los PURCHASE, puesto que con eso se
    //sabrá a quién pertenece un PURCHASE
        //Es decir que PURCHASE tendrá la FK con el ID de sell

//Store
    //la agregué por el rol que va a tener el encargado de bodega
    //pero seguirá siendo lo mismo que dije antes
        //es decir va a ser básicamente lo mismo que stock, solo
        //que con diferente formato de identificación y sin office.

        //Ahh no no. No debe existir, bueno si podría, pero por la manera
        //En que creaste producto, si add store, so you will have to add
        //another atribute that will be related with Store, but if the 
        //product is not in the store you will have to give a blank space
        //and I don't want this.
            //Also it remind me that if the case of pull or transfer a prod
            //from store to an office, because of the ID that it will be a PK
            //I won't be able to change it
                //so I'll have to delete the stock IF all of the products on
                //this are removed or transfer. If not, so nothing happens.


//STOCK
    //tendrá una línea por diferente tipo de producto, o de un mismo prod,
    //si es que este pertenece a otra tienda...

//con FK
    //prodcut (2)
    //purchase (2)
    //contract (2)
    //sale (2)
    //stock (1)


//IMAGES
    //si está muy difícil guardar las img en la DB 
    //entonces solo coloca una imagen general en los
    //cuadritos que colocaste

//bien podría haber guardado ADRESS para employee
//pero eso implicaría crear una tabla PERSONA y como
//ya lo hice así por separado, y sé que si lo hago,
//tendré que hacer más relaciones y por tanto JOINS
//entonces pues no lo haré :p

//arreglar y agregar tablas, interfaz LISTA!


//NOTA ABOUT POSTGRESQL

//la FK de preferencia debe corresponder a la PK de la
//entidad primordial en las interacciones, es decir
//aquella que por las acciones a relaizar, es la que se
//debe visitar de primero, por lógica y si se quiere 
//hacer el proceso eficiente
    //Eso lo descubrí por lo de Employee/contract
    //pues estba pensando que, bien podía colocar
    //el ID de contract en Employee, pero si hago eso
    //Se complicaría la cosa, porque para hallar a un
    //empleado teniendo el ID, tendría que buscarlo
    //en contrato, luego hacer con eso el JOIN
    //y pues resulta más rápido que el dato a buscar
    //Sea una PK, porque resulta más fácil para la DB
    //y eso es lo que sucede cuando tengo como PK, el
    //ID de employee...


//ENUMS
 - justificación: como si se puede seleccionar los valores de los ENUM con un SELECT y como no quier oingresar nada más a
   estos que el listado existente y quiero hacer casi todo con la DB y se puede add más cosas a los enum, entonces voy a
   usar estos para Brand, type and category. No para store pues ella tiene más cosas que addle*/

- pensaba en crear en todo caso un enum en Java y con eso setear los vals en la columna de la tabla
  appliance en este caso, PERO si se add otro, tendría que modif el código de Java y creo que para 
  ello se emplea la DB, es decir para datos cambiantes. entonces por buenas prácticas xD.
    - además así pruebo otra manera...

- structure
    CREATE TYPE brand AS ENUM ('');

//además si hubiera creado una tabla solo por ese dato tendría que haber empleado un join, y no iba
  a ser una sola columna con ese caso...
    - así que me ahorro JOINS xD
        -mira si puedes guardar más de una palabra en un enum, así como en java, como para reemplazar
         la TABLE store a un ENUM store
    - para insertar debes usar la palabra como si fuera un VARCHAR y el tipo deberá ser TEXT...
    - ENUM son case sensitive

//PRODUCT
    - con respecto a la tabla CTEGORY, la cree, porque como type and line van de la mano, entonces
      si los creaba por separado como ENUM, podrían cometerse algunos errores, como el colocar un
      tipo con la línea incorrecta, entonces lo que se hará es que cuando
        - se INSERT un producto, al select el typo, a partir de él se irá a buscar a la tabla de
          category, que línea le corresponde para así colocarla en el cbBox que no puede ser SELECT
          y al presionar SAVE, lo que se hará es ir a buscar el ID de la relación entre esos dos ele
          en categoría para insertarlo en APPLIANCE
        - para buscarlo, cuando se seleccione
            LINE- se seteará solo los TYPE que corresponden a ella(s), y todas si select ALL 
            TYPE- se colocará automáticamente la LINE corresp en el cbBox y si
                    > se cb de LINE, entonces se hará el punto1
                    > se cb de TYPE, se volverá a exe 2, porque ahora la línea es otra...

//ACUERDO
    //BUSCAR productos
        //si se selecciona ya sea ALL(type) o los 3 en LINE
            //entonces no habrá WHERE para las LINE y TYPE                
              (más que todo line), porque se quiere ver todo
              //Y en el caso de TYPE si es que se marca 3 de
                LINE, se pasaría a ALL 
             //y si es que se select ALL, puedes marcar o
               desmarcar todo... da lo mismo xD
                    //mejor marcar todo xd
        //si se selecciona +1 pero <3 en LINE, entonces
            //NO habrá WHERE para TYPE, porque es más de
              1 LINE y no los mismos tipos están en ella...
            //y solo se colocaría ALL en el cbBox TYPE
            //creo que en ecoline
                //mira si vas a considerar ese caso 
                  o vas a tratar parejo
                      //porque si sí, entonces ya bien
                        harías que no se pusiera en ALL
                        el TYPE cuando eco y UNO más
                        estuviera SELECT y buscarías en 
                        la DB
                      //o harías una bśuqueda previa 
                        para ver si hay de ese tipo en
                        AMBAS
                          //en DEFINITIVA harías el JOIN
                          para así dejar solo lo que hay
                          entre ambas
                              //esto justo después de que
                                suceda el hecho de que
                                eco y OTRO más esté select
                                  //es decir que después de
                                    eso se cb a la op de
                                    TYPE all, y se tendría
                                    lo recolectado por INNER
    


        
        

        

        
